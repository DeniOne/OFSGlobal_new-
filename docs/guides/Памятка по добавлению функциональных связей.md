# Памятка по добавлению функциональных связей

## Общие сведения

Функциональные связи позволяют отображать отношения между должностями, которые выполняют одинаковые функции в рамках организации. Это помогает визуализировать функциональную структуру компании, независимую от иерархической организационной структуры.

## Шаги по добавлению функциональных связей

### 1. Создание базовых таблиц в БД

1. Создаём таблицу `functions` для хранения функций:
   ```sql
   CREATE TABLE IF NOT EXISTS functions (
       id INTEGER PRIMARY KEY AUTOINCREMENT,
       name TEXT NOT NULL UNIQUE,
       code TEXT NOT NULL UNIQUE,
       description TEXT,
       is_active BOOLEAN DEFAULT 1,
       created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
       updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
   );
   ```

2. Создаём таблицу `functional_assignments` для связи функций с должностями:
   ```sql
   CREATE TABLE IF NOT EXISTS functional_assignments (
       id INTEGER PRIMARY KEY AUTOINCREMENT,
       position_id INTEGER NOT NULL,
       function_id INTEGER NOT NULL,
       percentage INTEGER DEFAULT 100,
       is_primary BOOLEAN DEFAULT 0,
       created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
       updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
       FOREIGN KEY (position_id) REFERENCES positions(id) ON DELETE CASCADE,
       FOREIGN KEY (function_id) REFERENCES functions(id) ON DELETE CASCADE
   );
   ```

### 2. Создание моделей Pydantic и SQLAlchemy

1. Создаём файл `models/function.py`:
   ```python
   from sqlalchemy import Column, Integer, String, Boolean, DateTime, func
   from app.db.base_class import Base

   class Function(Base):
       __tablename__ = "functions"

       id = Column(Integer, primary_key=True, index=True)
       name = Column(String, nullable=False, unique=True, index=True)
       code = Column(String, nullable=False, unique=True, index=True)
       description = Column(String, nullable=True)
       is_active = Column(Boolean, default=True)
       created_at = Column(DateTime, server_default=func.now())
       updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())
   ```

2. Создаём файл `models/functional_assignment.py`:
   ```python
   from sqlalchemy import Column, Integer, String, Boolean, DateTime, ForeignKey, func
   from app.db.base_class import Base

   class FunctionalAssignment(Base):
       __tablename__ = "functional_assignments"

       id = Column(Integer, primary_key=True, index=True)
       position_id = Column(Integer, ForeignKey("positions.id", ondelete="CASCADE"), nullable=False)
       function_id = Column(Integer, ForeignKey("functions.id", ondelete="CASCADE"), nullable=False)
       percentage = Column(Integer, default=100)
       is_primary = Column(Boolean, default=False)
       created_at = Column(DateTime, server_default=func.now())
       updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())
   ```

3. Создаём файл `schemas/function.py`:
   ```python
   from pydantic import BaseModel, Field
   from typing import Optional
   from datetime import datetime

   class FunctionBase(BaseModel):
       name: str
       code: str
       description: Optional[str] = None
       is_active: bool = True

   class FunctionCreate(FunctionBase):
       pass

   class FunctionUpdate(BaseModel):
       name: Optional[str] = None
       code: Optional[str] = None
       description: Optional[str] = None
       is_active: Optional[bool] = None

   class Function(FunctionBase):
       id: int
       created_at: datetime
       updated_at: datetime

       class Config:
           orm_mode = True
   ```

4. Создаём файл `schemas/functional_assignment.py`:
   ```python
   from pydantic import BaseModel
   from typing import Optional
   from datetime import datetime

   class FunctionalAssignmentBase(BaseModel):
       position_id: int
       function_id: int
       percentage: int = 100
       is_primary: bool = False

   class FunctionalAssignmentCreate(FunctionalAssignmentBase):
       pass

   class FunctionalAssignmentUpdate(BaseModel):
       position_id: Optional[int] = None
       function_id: Optional[int] = None
       percentage: Optional[int] = None
       is_primary: Optional[bool] = None

   class FunctionalAssignment(FunctionalAssignmentBase):
       id: int
       created_at: datetime
       updated_at: datetime

       class Config:
           orm_mode = True
   ```

### 3. Создание CRUD операций

1. Создаём файл `crud/crud_function.py`:
   ```python
   from sqlalchemy.ext.asyncio import AsyncSession
   from sqlalchemy.future import select
   from sqlalchemy import update, delete
   from typing import List, Optional
   from app.models.function import Function
   from app.schemas.function import FunctionCreate, FunctionUpdate

   class CRUDFunction:
       async def create(self, db: AsyncSession, *, obj_in: FunctionCreate) -> Function:
           db_obj = Function(**obj_in.dict())
           db.add(db_obj)
           await db.commit()
           await db.refresh(db_obj)
           return db_obj

       async def get(self, db: AsyncSession, id: int) -> Optional[Function]:
           result = await db.execute(select(Function).where(Function.id == id))
           return result.scalar_one_or_none()

       async def get_multi(
           self, db: AsyncSession, *, skip: int = 0, limit: int = 100
       ) -> List[Function]:
           result = await db.execute(select(Function).offset(skip).limit(limit))
           return result.scalars().all()

       async def update(self, db: AsyncSession, *, id: int, obj_in: FunctionUpdate) -> Optional[Function]:
           update_data = obj_in.dict(exclude_unset=True)
           if not update_data:
               return await self.get(db, id)
           
           await db.execute(
               update(Function)
               .where(Function.id == id)
               .values(**update_data)
           )
           await db.commit()
           return await self.get(db, id)

       async def delete(self, db: AsyncSession, *, id: int) -> bool:
           result = await db.execute(delete(Function).where(Function.id == id))
           await db.commit()
           return result.rowcount > 0

   function = CRUDFunction()
   ```

2. Создаём файл `crud/crud_functional_assignment.py`:
   ```python
   from sqlalchemy.ext.asyncio import AsyncSession
   from sqlalchemy.future import select
   from sqlalchemy import update, delete
   from typing import List, Optional
   from app.models.functional_assignment import FunctionalAssignment
   from app.schemas.functional_assignment import FunctionalAssignmentCreate, FunctionalAssignmentUpdate

   class CRUDFunctionalAssignment:
       async def create(self, db: AsyncSession, *, obj_in: FunctionalAssignmentCreate) -> FunctionalAssignment:
           db_obj = FunctionalAssignment(**obj_in.dict())
           db.add(db_obj)
           await db.commit()
           await db.refresh(db_obj)
           return db_obj

       async def get(self, db: AsyncSession, id: int) -> Optional[FunctionalAssignment]:
           result = await db.execute(select(FunctionalAssignment).where(FunctionalAssignment.id == id))
           return result.scalar_one_or_none()

       async def get_by_position(self, db: AsyncSession, position_id: int) -> List[FunctionalAssignment]:
           result = await db.execute(
               select(FunctionalAssignment)
               .where(FunctionalAssignment.position_id == position_id)
           )
           return result.scalars().all()

       async def get_by_function(self, db: AsyncSession, function_id: int) -> List[FunctionalAssignment]:
           result = await db.execute(
               select(FunctionalAssignment)
               .where(FunctionalAssignment.function_id == function_id)
           )
           return result.scalars().all()

       async def get_multi(
           self, db: AsyncSession, *, skip: int = 0, limit: int = 100
       ) -> List[FunctionalAssignment]:
           result = await db.execute(select(FunctionalAssignment).offset(skip).limit(limit))
           return result.scalars().all()

       async def update(self, db: AsyncSession, *, id: int, obj_in: FunctionalAssignmentUpdate) -> Optional[FunctionalAssignment]:
           update_data = obj_in.dict(exclude_unset=True)
           if not update_data:
               return await self.get(db, id)
           
           await db.execute(
               update(FunctionalAssignment)
               .where(FunctionalAssignment.id == id)
               .values(**update_data)
           )
           await db.commit()
           return await self.get(db, id)

       async def delete(self, db: AsyncSession, *, id: int) -> bool:
           result = await db.execute(delete(FunctionalAssignment).where(FunctionalAssignment.id == id))
           await db.commit()
           return result.rowcount > 0

   functional_assignment = CRUDFunctionalAssignment()
   ```

### 4. Создание API эндпоинтов

1. Создаём файл `api/api_v1/endpoints/functions.py`:
   ```python
   from fastapi import APIRouter, Depends, HTTPException
   from sqlalchemy.ext.asyncio import AsyncSession
   from typing import List, Any
   from app.api import deps
   from app.crud.crud_function import function
   from app.schemas.function import Function, FunctionCreate, FunctionUpdate

   router = APIRouter()

   @router.post("/", response_model=Function)
   async def create_function(
       *,
       db: AsyncSession = Depends(deps.get_db),
       function_in: FunctionCreate,
   ) -> Any:
       return await function.create(db=db, obj_in=function_in)

   @router.get("/", response_model=List[Function])
   async def read_functions(
       db: AsyncSession = Depends(deps.get_db),
       skip: int = 0,
       limit: int = 100,
   ) -> Any:
       return await function.get_multi(db=db, skip=skip, limit=limit)

   @router.get("/{id}", response_model=Function)
   async def read_function(
       *,
       db: AsyncSession = Depends(deps.get_db),
       id: int,
   ) -> Any:
       result = await function.get(db=db, id=id)
       if not result:
           raise HTTPException(status_code=404, detail="Function not found")
       return result

   @router.put("/{id}", response_model=Function)
   async def update_function(
       *,
       db: AsyncSession = Depends(deps.get_db),
       id: int,
       function_in: FunctionUpdate,
   ) -> Any:
       result = await function.get(db=db, id=id)
       if not result:
           raise HTTPException(status_code=404, detail="Function not found")
       return await function.update(db=db, id=id, obj_in=function_in)

   @router.delete("/{id}", response_model=bool)
   async def delete_function(
       *,
       db: AsyncSession = Depends(deps.get_db),
       id: int,
   ) -> Any:
       result = await function.get(db=db, id=id)
       if not result:
           raise HTTPException(status_code=404, detail="Function not found")
       return await function.delete(db=db, id=id)
   ```

2. Добавляем роутеры в файл `api/api_v1/api.py`:
   ```python
   # ... existing imports ...
   from app.api.api_v1.endpoints import functions, functional_assignments

   api_router = APIRouter()
   # ... existing routes ...
   api_router.include_router(functions.router, prefix="/functions", tags=["functions"])
   api_router.include_router(functional_assignments.router, prefix="/functional-assignments", tags=["functional_assignments"])
   ```

### 5. Типы TypeScript и сервисы для фронтенда

1. Добавляем типы в `frontend/src/types/function.ts`:
   ```typescript
   export interface Function {
     id: number;
     name: string;
     code: string;
     description?: string;
     is_active: boolean;
     created_at: string;
     updated_at: string;
   }

   export interface FunctionalAssignment {
     id: number;
     position_id: number;
     function_id: number;
     percentage: number;
     is_primary: boolean;
     created_at: string;
     updated_at: string;
   }
   ```

2. Создаём сервис `frontend/src/services/functionsService.ts`:
   ```typescript
   import api from './api';
   import { Function, FunctionalAssignment } from '../types/function';

   interface FunctionCreateDTO {
     name: string;
     code: string;
     description?: string;
     is_active?: boolean;
   }

   interface FunctionUpdateDTO {
     name?: string;
     code?: string;
     description?: string;
     is_active?: boolean;
   }

   interface FunctionalAssignmentCreateDTO {
     position_id: number;
     function_id: number;
     percentage?: number;
     is_primary?: boolean;
   }

   interface FunctionalAssignmentUpdateDTO {
     position_id?: number;
     function_id?: number;
     percentage?: number;
     is_primary?: boolean;
   }

   const functionsService = {
     // Методы для функций
     async getFunctions(): Promise<Function[]> {
       try {
         const { data } = await api.get('/functions');
         return data;
       } catch (error) {
         console.error('Ошибка при получении функций:', error);
         throw error;
       }
     },

     async getFunction(id: number): Promise<Function> {
       try {
         const { data } = await api.get(`/functions/${id}`);
         return data;
       } catch (error) {
         console.error(`Ошибка при получении функции с ID ${id}:`, error);
         throw error;
       }
     },

     async createFunction(functionData: FunctionCreateDTO): Promise<Function> {
       try {
         const { data } = await api.post('/functions', functionData);
         return data;
       } catch (error) {
         console.error('Ошибка при создании функции:', error);
         throw error;
       }
     },

     async updateFunction(id: number, functionData: FunctionUpdateDTO): Promise<Function> {
       try {
         const { data } = await api.put(`/functions/${id}`, functionData);
         return data;
       } catch (error) {
         console.error(`Ошибка при обновлении функции с ID ${id}:`, error);
         throw error;
       }
     },

     async deleteFunction(id: number): Promise<boolean> {
       try {
         const { data } = await api.delete(`/functions/${id}`);
         return data;
       } catch (error) {
         console.error(`Ошибка при удалении функции с ID ${id}:`, error);
         throw error;
       }
     },

     // Методы для функциональных назначений
     async getFunctionalAssignments(): Promise<FunctionalAssignment[]> {
       try {
         const { data } = await api.get('/functional-assignments');
         return data;
       } catch (error) {
         console.error('Ошибка при получении функциональных назначений:', error);
         throw error;
       }
     },

     async getFunctionalAssignmentsByPosition(positionId: number): Promise<FunctionalAssignment[]> {
       try {
         const { data } = await api.get(`/functional-assignments/position/${positionId}`);
         return data;
       } catch (error) {
         console.error(`Ошибка при получении функциональных назначений для должности с ID ${positionId}:`, error);
         throw error;
       }
     },

     async getFunctionalAssignmentsByFunction(functionId: number): Promise<FunctionalAssignment[]> {
       try {
         const { data } = await api.get(`/functional-assignments/function/${functionId}`);
         return data;
       } catch (error) {
         console.error(`Ошибка при получении функциональных назначений для функции с ID ${functionId}:`, error);
         throw error;
       }
     },

     async createFunctionalAssignment(assignmentData: FunctionalAssignmentCreateDTO): Promise<FunctionalAssignment> {
       try {
         const { data } = await api.post('/functional-assignments', assignmentData);
         return data;
       } catch (error) {
         console.error('Ошибка при создании функционального назначения:', error);
         throw error;
       }
     },

     async updateFunctionalAssignment(id: number, assignmentData: FunctionalAssignmentUpdateDTO): Promise<FunctionalAssignment> {
       try {
         const { data } = await api.put(`/functional-assignments/${id}`, assignmentData);
         return data;
       } catch (error) {
         console.error(`Ошибка при обновлении функционального назначения с ID ${id}:`, error);
         throw error;
       }
     },

     async deleteFunctionalAssignment(id: number): Promise<boolean> {
       try {
         const { data } = await api.delete(`/functional-assignments/${id}`);
         return data;
       } catch (error) {
         console.error(`Ошибка при удалении функционального назначения с ID ${id}:`, error);
         throw error;
       }
     }
   };

   export default functionsService;
   ```

### 6. Обновление визуализации организационной структуры

1. Модифицируем компонент `StructureChartPage.tsx` для поддержки отображения функциональных связей:
   - Добавляем опцию переключения между иерархическим и функциональным представлением
   - Создаём логику для отображения функциональных связей

2. Создаём новый компонент `FunctionalRelationsChart.tsx` для визуализации функциональных связей

### 7. Интеграция и тестирование

1. Генерируем миграцию для создания новых таблиц
2. Тестируем API-эндпоинты с помощью Swagger или Postman
3. Проверяем отображение функциональных связей в интерфейсе

## Полезные команды

### Создание миграции
```bash
alembic revision --autogenerate -m "Add functions and functional assignments tables"
```

### Применение миграции
```bash
alembic upgrade head
```

### Тестирование API
```bash
curl -X GET "http://localhost:8000/api/v1/functions" -H "accept: application/json"
```

## Примечания

1. Процент (percentage) в функциональном назначении показывает, какую часть рабочего времени сотрудник должен уделять данной функции
2. Флаг is_primary определяет, является ли данная функция основной для должности
3. При визуализации функциональные связи можно отображать пунктирными линиями, чтобы отличать их от иерархических 